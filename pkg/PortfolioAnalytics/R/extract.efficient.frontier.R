###############################################################################
# R (http://r-project.org/) Numeric Methods for Optimization of Portfolios
#
# Copyright (c) 2004-2010 Kris Boudt, Peter Carl and Brian G. Peterson
#
# This library is distributed under the terms of the GNU Public License (GPL)
# for full details see the file COPYING
#
# $Id$
#
###############################################################################

#' extract the efficient frontier of portfolios that meet your objectives over a range of risks
#' 
#' note that this function will be extremely sensitive to the objectives in your
#' \code{\link{constraint}} object.  It will be especially obvious if you 
#' are looking at a risk budget objective and your return preference is not set high enough.
#' 
#' If you do not have a set of portfolios to extract from, portfolios may be generated automatically, which would take a very long time.
#'  
#' @param portfolios set of portfolios as generated by \code{\link{extractStats}}
#' @param from minimum value of the sequence
#' @param to maximum value of the sequence
#' @param by number to increment the sequence by
#' @param risk.col string name of column to use for risk (horizontal axis)
#' @param \dots any other passthru parameters
#' @param R an xts, vector, matrix, data frame, timeSeries or zoo object of asset returns
#' @param constraints an object of type "constraints" specifying the constraints for the optimization, see \code{\link{constraint}}
#' @param optimize_method one of "DEoptim" or "random"
#' @export
extract.efficient.frontier <- 
function (portfolios=NULL, 
          risk.col='ES', from=0, to=1, by=.005, 
          ..., 
          R = NULL, 
          constraints = NULL, 
          optimize_method='random')
{
    set<-seq(from=from,to=to,by=by)
    set<-cbind(quantmod::Lag(set,1),as.matrix(set))[-1,]
    if(is.null(portfolios)){
        if(!is.null(R)){
            portfolios<-optimize.portfolio(constraints=constraints, R=R, optimize_method=optimize_method, ...)
        } else {
            stop('you must specify either a portfolio set or a return series')
        }
    }
    
    xtract<-extractStats(portfolios)
    #if("package:multicore" %in% search() || require("multicore",quietly = TRUE)){
    #    mclapply
    #}
    stopifnot("package:foreach" %in% search() || require("foreach",quietly = TRUE))
    
    result <- foreach(i=1:nrow(set),.combine=rbind) %do% {
        xtract[which.min(xtract[which(xtract[,risk.col]>=set[i,1] & xtract[,risk.col]<set[i,2]),'out']),]
    }
    return(result)
}
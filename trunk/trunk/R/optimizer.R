# Optimizer Functions

# Copyright 2006 Brian G. Peterson , Aaron van Meerten, Peter Carl


################################################################################
# FUNCTIONS:
#
#
#
#
#
#
#
#
#
#
#
#
#
#
################################################################################

# Check to see if the required libraries are loaded
if(!require("fBasics", quietly=TRUE)) {
    stop("package", sQuote("fBasics"), "is needed.  Stopping")
}
if(!require("fPortfolio", quietly=TRUE)) {
    stop("package", sQuote("fPortfolio"), "is needed.  Stopping")
}
if(!require("tseries", quietly=TRUE)) {
    stop("package", sQuote("tseries"), "is needed.  Stopping")
}

# ------------------------------------------------------------------------------
weight.grid =
function (columnnames, seqstart=.05, seqend=.25, seqstep=.05)
{   # @author Aaron van Meerten

    # Description:

    # Function loosely based on expand.grid
    #
    # Generate and returns a grid of weighting vectors
    # containing all unique combinations
    # of seq parameters where rowsum = 1
    #
    # columnnames = vector of names for the grid columns
    # seqstart = start/from value for seq()
    # seqend = end/to value for seq()
    # seqstep = step/by value for seq()
    #
    # we will use seq(seqstart, seqend, seqstep)
    #

    # FUNCTION:

    result = NA

    # Return Value:
    result
}

# ------------------------------------------------------------------------------
maxdrawdown
function (x)
{ # adapted from package "tseries"
    if (NCOL(x) > 1)
        stop("x is not a vector or univariate time series")
    if (any(is.na(x)))
        stop("NAs in x")
    cmaxx <- cummax(x) - x
    mdd <- max(cmaxx)
    to <- which(mdd == cmaxx)
    from <- double(NROW(to))
    for (i in 1:NROW(to)) from[i] <- max(which(cmaxx[1:to[i]] ==
        0))
    return(list(maxdrawdown = mdd, from = from, to = to))
}

# ------------------------------------------------------------------------------
cut.returns =
function (R, cutrow, startrow=1)
{   # @author Brian G. Peterson

    # Description:

    # FUNCTION:
    result = R[startrow:cutrow,]

    # Return Value:
    result
}



# ------------------------------------------------------------------------------
weighttest =
function (weightgrid, test=1)
{
    rows=nrow(weightgrid)

    result=NA

    for(row in 1:rows) {
        r = as.vector(weightgrid[row,])
        #if (!is.numeric(r)) stop("The selected row is not numeric")

        if (sum(r) == test) {
            #if (result=NA) {
                #create data.frame
            #    result=data.frame(r=r)
            #} else {
                r=data.frame(r=r)
                result=cbind(result,r)
            #}
        }
    } #end rows loop

    # Return Value:
    result

}

# ------------------------------------------------------------------------------
#WeightedReturns =
# use pfolioReturn(returnarray,weightingvector) from fPortfolio
WeightedReturns =
function (R, weightgrid, from, to)
{ # @author Brian G. Peterson

    # Description:
    # This is the workhorse of the backtest architecture.
    # Any optimization backtesting model must
    #     - create portfolios,
    #     - analyze their returns,
    #     - and allow you to use some metric, function, or algorithm
    #       to analyze the results
    #
    # function takes a set of returns, a set of portfolio weights,
    # and a timeframe to operate within, and generates a set of statistics
    # for every possible weight.
    #
    # When you calculate statistics for all possible weights generated by
    # a brute force method, an estimation method, some function,
    # a regression, etc., you can then run tests against the results "in-sample"
    # to determine which weighting vector you want to use "out-of-sample"
    # in the next rolling period.
    #
    # This function is extremely computationally intensive, because it is doing
    # a lot of things with every single possible weighting vector, so you want
    # to be able to run it and store the results for later analysis.
    # It is best to strike a balance between placing functions in here that
    # you will need to help choose the optimal weighting vector, and be
    # parsimonious, as these calculations may be run tens of thousands of times
    # in any given backtest.  Remember that once you have chosen an optimal
    # portfolio or a sub-set of possible optimal portfolios, you can run more
    # exhaustive analytics on each of your candidates later, rather than on the
    # entire set of all possible portfolios.
    #
    # R             data structure of returns
    # weightgrid    each row contains one weighting vector, same number of columns as your returns
    # from          where to cut the beginning of the return stream
    # to            where to cut the end of the return stream
    #
    # @returns      data frame where each row has the same index number as a weighting vector,
    #               and each column is one of your metrics from inside this function

    # Setup:
    rows=nrow(weightgrid)

    result=NA

    # data type conditionals
    # cut the return series for from:to
    if (class(R) == "timeSeries") {
        fullR = R@Data[1,to]
        R = R@Data[from:to,]
    } else {
        fullR = R[1:to,]
        R = R[from:to,]
    }

    if (ncol(weightgrid) != ncol(R)) stop ("The Weighting Vector and Return Collection do not have the same number of Columns.")

    # Function:
    for(row in 1:rows) {

        w = as.numeric(weightgrid[row,])
        # test each row in the weighting vectors against the right dates in the return collection

        # pfolioReturn
        returns=pfolioReturn(R,w)
        historicalreturns=pfolioReturn(fullR,w)

        # cumulative geometric Return for the period
        annualReturn=cumulativeReturn(returns)

        # 3yr annualizedReturn
        # look back three years and calculate annualized mean return


        # modifiedVaR(95%) from pfolioReturn
        mVaR = modifiedVaR(returns, p=0.95)

        # modifiedVaR(95%) from pfolioReturn since inception
        mVaRi = modifiedVaR(historicalreturns, p=0.95)

        # Expected Shortfall
        # commented because it isn't useful in our analyses
        # ES = CVaRplus(returns, weights = NULL, alpha = 0.05)[1]

        # maxDrawdown
        mddlist= maxdrawdown(returns)

        # Annualized Sharpe Ratio since inception

        # 3yr Annualized Sharpe Ratio
        # look back three years and calculate annualized Sharpe ratio

        # construct a data structure that holds each result for this row
        if (row==1) {
                #create data.frame
                result=data.frame()
                resultrow=data.frame()
        }
        # first cbind the columns
        resultrow = cbind( annualReturn, mVaR, mVaRi, mddlist$maxdrawdown, ES )

        rownames(resultrow) = row

        # then rbind the rows
        result    = rbind(result,resultrow)

    } #end rows loop

    # set pretty labels for the columns
    colnames(result)=c("Annualized Return","modifiedVaR(95%)-period","modifiedVaR(95%)-inception","Max Drawdown")

    # Return Value:
    result

}

# ------------------------------------------------------------------------------
BruteForcePortfolios =
function(R,weightgrid,yeargrid)
{ # @author Brian G. Peterson

    # Description:
    #
    # Performs the looping and storage of the base analytics for your series
    # of possible portfolios.  I've titled the third parameter 'yeargrid',
    # but it is really a 'rolling window grid', although these will often be years.
    # We slice the computation into these years or rolling periods,
    # and store the results separately, because each of these rolling periods will
    # have one solution for each possible weighting vector.  By generating them and
    # storing them for all weighting vecotrs in every period, you can do all the hard
    # computational work in one pass, and then reuse the data set over and over again
    # in multiple analytic tests, methods, or hypotheses for choosing in-sample results
    # to use as out-of-sample weights.

    # Setup:
    rows=nrow(yeargrid)

    # Function:
    for (rnum in 1:rows) {
        row = yeargrid[rnum,]
        yearname=rownames(row)
        from = row [,1]
        to   = row [,2]

        # construct a data structure that holds each result for this year
        # first cbind
        resultarray = WeightedReturns(R, weightgrid, from, to)

        # then write a CSV
        write.table(resultarray, file = paste(yearname,".csv",sep=""),
            append = FALSE, quote = TRUE, sep = ",",
            eol = "\n", na = "NA", dec = ".", row.names = TRUE,
            col.names = TRUE, qmethod = "escape")

        print(yearname)
        # print(resultarray)
    }  # end row loop
}

# ------------------------------------------------------------------------------
BacktestData =
function()
{ # @author Brian G. Peterson

    # Description:
    #
    # complete brute force hackjob to get out of sample results

    # Setup:
    WR1997=read.table("1997.csv",header=TRUE, row.names = 1,sep = ",")
    WR1998=read.table("1998.csv",header=TRUE, row.names = 1,sep = ",")
    WR1999=read.table("1999.csv",header=TRUE, row.names = 1,sep = ",")
    WR2000=read.table("2000.csv",header=TRUE, row.names = 1,sep = ",")
    WR2001=read.table("2001.csv",header=TRUE, row.names = 1,sep = ",")
    WR2002=read.table("2002.csv",header=TRUE, row.names = 1,sep = ",")
    WR2003=read.table("2003.csv",header=TRUE, row.names = 1,sep = ",")
    WR2004=read.table("2004.csv",header=TRUE, row.names = 1,sep = ",")
    WR2005=read.table("2005.csv",header=TRUE, row.names = 1,sep = ",")

    result=list(WR1997,WR1998,WR1999,WR2000,WR2001,WR2002,WR2003,WR2004,WR2005)
    names(result)<-c("1997","1998","1999","2000","2001","2002","2003","2004","2005")

    #Return:
    result
}

# ------------------------------------------------------------------------------
Backtest =
function(R,portfolioreturns, yeargrid )
{

    rows=nrow(yeargrid)

    # Function:
    for (rnum in 2:rows) {
        insample    = yeargrid[rnum-1,]
        outofsample = yeargrid[rnum,]
        infrom      = insample [,1]
        into        = insample [,2]
        outfrom     = outofsample [,1]
        outto       = outofsample [,2]
        yearname    = rownames(insample)
        outname     = rownames(outofsample)

        # print(outname)

        #Check Utility fn for insample , and apply to out of sample row

        ##################################
        # Risk Reduction utility functions
        # for utility function
        # w' = min(modifiedVaR(p=0.95))
        #minmodVaR  = which.min(portfolioreturns[[yearname]][,"modifiedVaR.95...period"])
        minmodVaRi = which.min(portfolioreturns[[yearname]][,"modifiedVaR.95...inception"])

        # for utility function
        # w' = max(return/modifiedVaR) for both modifiedVaR.period and modifiedVaR.inception
        #modSharpe  = which.max(portfolioreturns[[yearname]][,"Annualized.Return"]/portfolioreturns[[yearname]][,"modifiedVaR.95...period"])
        modSharpei = which.max(portfolioreturns[[yearname]][,"Annualized.Return"]/portfolioreturns[[yearname]][,"modifiedVaR.95...inception"])

        # for utility function
        # w' = min(modifiedVaR(p=0.95)) such that return is greater than the benchmark
        minVaRretoverBM = which.min(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][,"Annualized.Return"]>=cumulativeReturn(R[infrom:into,13])),"modifiedVaR.95...period"])
        if (length(minVaRretoverBM)==0) { minVaRretoverBM = NA }

        #for utility function
        #w' = max(return) such that modifiedVaR is less than modifiedVaR(benchmark)
        maxmodVaRltBM=which.max(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][,"modifiedVaR.95...period"]<modifiedVaR(R[infrom:into,13],p=0.95)),"Annualized.Return"])
        if (length(maxmodVaRltBM)==0) { maxmodVaRltBM = NA }

        #add utility functions tor Equal weighted portfolio benchmark
        # for utility function
        # w' = min(modifiedVaR(p=0.95)) such that return is greater than equal weighted portfolio
        minVaRretoverEW = which.min(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][,"Annualized.Return"]>=portfolioreturns[[yearname]][40063,"Annualized.Return"]),"modifiedVaR.95...period"])
        if (length(minVaRretoverEW)==0) { minVaRretoverEW = NA }

        #for utility function
        #w' = max(return) such that modifiedVaR is less than modifiedVaR(equal weighted)
        maxmodVaRltEW=which.max(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][,"modifiedVaR.95...period"]<portfolioreturns[[yearname]][40063,"Annualized.Return"]),"Annualized.Return"])
        if (length(maxmodVaRltEW)==0) { maxmodVaRltEW = NA }


        # construct a data structure that holds each result for this row
        if (rnum==2) {
                #create data.frame
                result=data.frame()
                resultrow=data.frame()
        }
        # first cbind the columns
        resultrow = cbind(minmodVaRi, modSharpei, minVaRretoverBM, maxmodVaRltBM, minVaRretoverEW, maxmodVaRltEW)

        rownames(resultrow) = outname

        # then rbind the rows
        result    = rbind(result,resultrow)
        # print(resultarray)
    }  # end row loop

    # Result:
    result
}

# ------------------------------------------------------------------------------
backtestDisplay =
function (R, portfolioreturns, yeargrid, backtestresults, show="Annualized.Return" )
{ # a function by Brian G. Peterson

    rows=nrow(yeargrid)-1

    # Function:
    for (rnum in 2:rows) {
        yearrow = yeargrid[rnum,]
        from      = yearrow [,1]
        to        = yearrow [,2]
        yearname    = rownames(yearrow)

        # construct a data structure that holds each result for this row
        if (rnum==1) {
                #create data.frame
                result=data.frame()
                resultrow=data.frame()
        }
        #if(rnum==rows){return}

        # now build our results
        FoFIndex      = cumulativeReturn (R[from:to,13]) #do something spiffy to show the same stats for FoHF index
        EqualWeighted = portfolioreturns[[yearname]][40063,show]

        #get funky with the backtest array
        backtestrow=t(portfolioreturns[[yearname]][t(backtestresults[yearname,]),"Annualized.Return"])
        #print(backtestrow)
        colnames(backtestrow)=colnames(backtestresults)

        # first cbind the columns
        resultrow = cbind( FoFIndex, EqualWeighted, backtestrow)

        rownames(resultrow) = yearname

        # then rbind the rows
        result    = rbind(result,resultrow)
        # print(resultarray)

    } # end rows loop

    #Result:
    result

}

# ------------------------------------------------------------------------------
# GeometricReturn
# use annualizedReturn or cumulativeReturn from Peter Carl in performance-analytics.R
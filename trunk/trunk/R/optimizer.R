# Optimizer Functions

################################################################################
#
# CONFIDENTIAL, NOT FOR DISTRIBUTION
#
################################################################################

# Copyright 2006 Brian G. Peterson , Aaron van Meerten, Peter Carl
# $Id: optimizer.R,v 1.19 2007-01-26 13:24:02 brian Exp $

################################################################################
# FUNCTIONS:
#
# BruteForcePortfolios (R,weightgrid,yeargrid)
# BacktestData ()
# Backtest (R,portfolioreturns, yeargrid, cutat=1000000 )
# weight.grid (columnnames, seqstart=.05, seqend=.25, seqstep=.05)
# maxdrawdown (R)
# cut.returns (R, cutrow, startrow=1)
# weighttest (weightgrid, test=1)
# WeightedReturns (R, weightgrid, from, to)
# backtestDisplay (R, portfolioreturns, yeargrid, backtestresults, show="Cumulative.Return" )
# MonthlyBacktestResults (R, weightgrid, yeargrid, backtestweights)
#
################################################################################

# Check to see if the required libraries are loaded
if(!require("fBasics", quietly=TRUE)) {
    stop("package", sQuote("fBasics"), "is needed.  Stopping")
}
if(!require("fPortfolio", quietly=TRUE)) {
    stop("package", sQuote("fPortfolio"), "is needed.  Stopping")
}
if(!require("fOptions", quietly=TRUE)) {
    stop("package", sQuote("fBasics"), "is needed.  Stopping")
}
if(!require("tseries", quietly=TRUE)) {
    stop("package", sQuote("tseries"), "is needed.  Stopping")
}
# also needs Peter Carl's "performance-analytics.R"
# do we always source it?

# ------------------------------------------------------------------------------
weight.grid =
function (columnnames, seqstart=.05, seqend=.25, seqstep=.05)
{   # @author Aaron van Meerten

    # Description:

    # Function loosely based on expand.grid
    #
    # Generate and returns a grid of weighting vectors
    # containing all unique combinations
    # of seq parameters where rowsum = 1
    #
    # columnnames = vector of names for the grid columns
    # seqstart = start/from value for seq()
    # seqend = end/to value for seq()
    # seqstep = step/by value for seq()
    #
    # we will use seq(seqstart, seqend, seqstep)
    #

    # FUNCTION:

    result = NA

    # Return Value:
    result
}

# ------------------------------------------------------------------------------
maxdrawdown
function (x)
{ # adapted from package "tseries"
    if (NCOL(x) > 1)
        stop("x is not a vector or univariate time series")
    if (any(is.na(x)))
        stop("NAs in x")
    cmaxx <- cummax(x) - x
    mdd <- max(cmaxx)
    to <- which(mdd == cmaxx)
    from <- double(NROW(to))
    for (i in 1:NROW(to)) from[i] <- max(which(cmaxx[1:to[i]] ==
        0))
    return(list(maxdrawdown = mdd, from = from, to = to))
}

# ------------------------------------------------------------------------------
cut.returns =
function (R, cutrow, startrow=1)
{   # @author Brian G. Peterson

    # Description:

    # FUNCTION:
    result = R[startrow:cutrow,]

    # Return Value:
    result
}



# ------------------------------------------------------------------------------
weighttest =
function (weightgrid, test=1)
{
    rows=nrow(weightgrid)

    result=NA

    for(row in 1:rows) {
        r = as.vector(weightgrid[row,])
        #if (!is.numeric(r)) stop("The selected row is not numeric")

        if (sum(r) == test) {
            #if (result=NA) {
                #create data.frame
            #    result=data.frame(r=r)
            #} else {
                r=data.frame(r=r)
                result=cbind(result,r)
            #}
        }
    } #end rows loop

    # Return Value:
    result

}

# ------------------------------------------------------------------------------
#WeightedReturns =
# use pfolioReturn(returnarray,weightingvector) from fPortfolio
WeightedReturns =
function (R, weightgrid, from, to)
{ # @author Brian G. Peterson

    # Description:
    # This is the workhorse of the backtest architecture.
    # Any optimization backtesting model must
    #     - create portfolios,
    #     - analyze their returns,
    #     - and allow you to use some metric, function, or algorithm
    #       to analyze the results
    #
    # function takes a set of returns, a set of portfolio weights,
    # and a timeframe to operate within, and generates a set of statistics
    # for every possible weight.
    #
    # When you calculate statistics for all possible weights generated by
    # a brute force method, an estimation method, some function,
    # a regression, etc., you can then run tests against the results "in-sample"
    # to determine which weighting vector you want to use "out-of-sample"
    # in the next rolling period.
    #
    # This function is extremely computationally intensive, because it is doing
    # a lot of things with every single possible weighting vector, so you want
    # to be able to run it and store the results for later analysis.
    # It is best to strike a balance between placing functions in here that
    # you will need to help choose the optimal weighting vector, and be
    # parsimonious, as these calculations may be run tens of thousands of times
    # in any given backtest.  Remember that once you have chosen an optimal
    # portfolio or a sub-set of possible optimal portfolios, you can run more
    # exhaustive analytics on each of your candidates later, rather than on the
    # entire set of all possible portfolios.
    #
    # R             data structure of historical returns
    # weightgrid    each row contains one weighting vector, same number of columns as your returns
    # from          where to cut the beginning of the return stream
    # to            where to cut the end of the return stream
    #
    # @returns      data frame where each row has the same index number as a weighting vector,
    #               and each column is one of your metrics from inside this function

    # Setup:
    rows=nrow(weightgrid)

    result=NA

    if (from < 1) from = 1
    if (to > rows) to = rows

    # data type conditionals
    # cut the return series for from:to
    if (class(R) == "timeSeries") {
        fullR = R@Data[1:to,]
        R = R@Data[from:to,]
    } else {
        fullR = R[1:to,]
        R = R[from:to,]
    }

    if (ncol(weightgrid) != ncol(R)) stop ("The Weighting Vector and Return Collection do not have the same number of Columns.")

    # Function:
    for(row in 1:rows) {

        w = as.numeric(weightgrid[row,])
        # test each row in the weighting vectors against the right dates in the return collection

        # pfolioReturn
        returns=pfolioReturn(R,w)
        # pfolioReturn, since inception
        #historicalreturns=pfolioReturn(fullR,w)

        # cumulative geometric Return for the period
        if (any(is.na(returns))) {
            print( paste("NA's in returns: ",row, " ",w," from ", from) )
            #browser()
        }
        cumReturn=cumulativeReturn(returns)
        threeyrfrom = from-24
        if (threeyrfrom < 1 ) threeyrfrom = 1
        threeyrreturns = pfolioReturn(fullR[threeyrfrom:to,],w)
        if (any(is.na(threeyrreturns))) {
            print( paste("NA's in threeyrreturns: ",row, " ",w," from ",from ) )
            #browser()
        }

        # 3yr  Mean Return
        # look back three years and calculate annualized mean return
        # use annualizedReturn fn instead of cumulativeReturn
        ThreeYrMeanReturn = mean(threeyrreturns)

        # modifiedVaR(95%) from pfolioReturn
        PeriodmodVaR = modifiedVaR(returns, p=0.95)

        # modifiedVaR(95%) from pfolioReturn since inception
        # InceptionmodVaR = modifiedVaR(historicalreturns, p=0.95)

        # modifiedVaR(95%) from pfolioReturn since inception
        ThreeYrmodVaR = modifiedVaR(threeyrreturns, p=0.95)

        # Expected Shortfall
        # commented because it isn't useful in our analyses
        # ES = CVaRplus(returns, weights = NULL, alpha = 0.05)[1]

        # maxDrawdown
        mddlist= maxdrawdown(returns)

        # Sharpe Ratio in period
        PeriodSharpe=sharpeRatio(returns)

        # Sharpe Ratio since inception
        # InceptionSharpe=sharpeRatio(historicalreturns)

        # 3yr trailing Sharpe Ratio
        # look back three years and calculate annualized Sharpe ratio
        ThreeYrSharpe=sharpeRatio(threeyrreturns)

        # Omega
        # Looks back three years
        Omega = omega (as.vector(threeyrreturns),method="simple" )

        # Standard Deviation
        StdDev = sd(returns, na.rm = TRUE)
        ThreeYrStdDev = sd(threeyrreturns, na.rm = TRUE)

        # construct a data structure that holds each result for this row
        if (row==1) {
                #create data.frame
                result=data.frame()
                resultrow=data.frame()
        }
        # first cbind the columns
        resultrow = cbind( cumReturn, ThreeYrMeanReturn, PeriodmodVaR, ThreeYrmodVaR, mddlist$maxdrawdown,
                             PeriodSharpe, ThreeYrSharpe, Omega, StdDev, ThreeYrStdDev )

        rownames(resultrow) = row

        # then rbind the rows
        result    = rbind(result,resultrow)

    } #end rows loop

    # set pretty labels for the columns
    colnames(result)=c("Cumulative Return","Mean Return,3 yr","modifiedVaR,period","modifiedVaR,3yr","Max Drawdown",
                        "Sharpe,period","Sharpe,3 yr", "Omega", "Std Dev","Std Dev,3yr" )

    # Return Value:
    result

}

# ------------------------------------------------------------------------------
BruteForcePortfolios =
function(R,weightgrid,yeargrid)
{ # @author Brian G. Peterson

    # Description:
    #
    # Performs the looping and storage of the base analytics for your series
    # of possible portfolios.  I've titled the third parameter 'yeargrid',
    # but it is really a 'rolling window grid', although these will often be years.
    # We slice the computation into these years or rolling periods,
    # and store the results separately, because each of these rolling periods will
    # have one solution for each possible weighting vector.  By generating them and
    # storing them for all weighting vectors in every period, you can do all the hard
    # computational work in one pass, and then reuse the data set over and over again
    # in multiple analytic tests, methods, or hypotheses for choosing in-sample results
    # to use as out-of-sample weights.
    #
    # @todo add optional subdirectory tp keep different backtests apart
    #
    # R                 data frame of historical returns
    #
    # weightgrid        each row contains one weighting vector, same number of columns as your returns
    #
    # yeargrid          list of from/to vectors for the periods we want to backtest over
    #
    # Return:
    # portfolioreturns  list of data frames of set of returns for all possible portfolios
    #                   (output of BruteForcePortfolios function)

    # Setup:
    rows=nrow(yeargrid)

    # Function:
    print( paste("Started:",date()) )
    for (rnum in 1:rows) {
        row = yeargrid[rnum,]
        yearname=rownames(row)
        from = row [,1]
        to   = row [,2]

        if (   1  > from ) from = 1
        if ( rows > to   ) to   = rows

        # construct a data structure that holds each result for this year
        # first cbind
        resultarray = WeightedReturns(R, weightgrid, from, to)

        # then write a CSV
        write.table(resultarray, file = paste(yearname,".csv",sep=""),
            append = FALSE, quote = TRUE, sep = ",",
            eol = "\n", na = "NA", dec = ".", row.names = TRUE,
            col.names = TRUE, qmethod = "escape")

        print( paste("Completed",yearname,":",date()) )
        # print(resultarray)
    }  # end row loop
}

# ------------------------------------------------------------------------------
BacktestData =
function(yeargrid)
{ # @author Brian G. Peterson

    # Description:
    #
    # load the data into a list suitable for use by Backtest and BacktestDisplay functions
    # use the yeargrid used by BruteForcePortfolios to figure out which files to load
    #
    # @todo add optional subdirectory to keep different backtests apart
    #
    # yeargrid          list of from/to vectors for the periods we've run the backtest over
    #                   yeargrid will have one row for the last out of sample year,
    #                   which is not calculated by BruteForcePortfolios

    # Function:
    rows=nrow(yeargrid)-1 # take out the out of sample year, for which there is no data

    for (rnum in 1:rows) {
        row = yeargrid[rnum,]
        yearname=rownames(row)
        # print(yearname)
        currentyeardata  = read.table(paste(yearname,".csv",sep=""),header=TRUE, row.names = 1,sep = ",")
        if (rnum==1) {
            #create e,ty list, as c() doesn't work the way you would expect with a list
            result=vector("list")
        }

        #assign each year into the list using the yearname as the index
        result[[yearname]]=currentyeardata

    }
    names(result) = t(rownames(yeargrid[1:rows,]))

    #Return:
    result
}

# ------------------------------------------------------------------------------
Backtest =
function(R,portfolioreturns, yeargrid, cutat=1000000, benchmarkreturns )
{
    # Description:
    #
    # complete brute force hackjob to get out of sample results
    #
    # Given a set of historical returns R, and a set of portfolio retrurns calculated from
    # the BruteForcePortfolios function, we can now apply several utility functions to
    # find the best portgolio out of the universe of all sample portfolios.
    #
    # Basically, we find and in-sample solution to each utility function, and store the
    # weighting vector for that portfolio as our strategic weight for use out of sample.
    # by testing several utility functions, we can examine the models for bias, and determine
    # which utility function produces the most acceptable out of sample results.
    #
    # R                 data frame of historical returns
    #
    # portfolioreturns  list of data frames of set of returns for all possible portfolios
    #                   (output of BruteForcePortfolios function)
    #
    # yeargrid          list of from/to vectors for the periods we want to backtest over
    #
    # cutat             numerical index to stop comparing the portfolioreturns at.
    #                   used to slice the weighted returns at particular weight
    #
    # benchmarkreturns  return vector for benchmark, should match the dates on
    #                   the in-sample portfolio returns


    # Setup:
    rows=nrow(yeargrid)

    benchmarkreturns = as.vector(benchmarkreturns)

    # Function:
    for (rnum in 2:rows) {
        insample    = yeargrid[rnum-1,]
        outofsample = yeargrid[rnum,]
        infrom      = insample [,1]
        into        = insample [,2]
        outfrom     = outofsample [,1]
        outto       = outofsample [,2]
        yearname    = rownames(insample)
        outname     = rownames(outofsample)
        portfoliorows=nrow(portfolioreturns[[yearname]])
        if (cutat<portfoliorows) {
            portfoliorows=cutat
        }

        # print(outname)

        #Check Utility fn for insample , and apply to out of sample row



        # add Equalweighted
        EqualWeighted = 1

        ##################################
        # Risk Reduction utility functions
        # for utility function
        # w' = min(modifiedVaR(p=0.95))
        minmodVaR  = which.min(portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.period"])
        #minmodVaRi = which.min(portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.inception"])
        minmodVaR3yr  = which.min(portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.3yr"])

        # for utility function
        # w' = max(return/modifiedVaR) for both modifiedVaR.period and modifiedVaR.inception
        #modSharpe  = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"]/portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.period"])
        modSharpe3yr  = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"]/portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.3yr"])
        #modSharpei = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"]/portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.inception"])

        # for utility function
        # w' = max(return/Max.Drawdown)
        ReturnOverDrawdown = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"]/portfolioreturns[[yearname]][1:portfoliorows,"Max.Drawdown"])

        # for utility function
        # w' = max(return)
        maxReturn = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"])

        # for utility function
        # w' = min(modifiedVaR(p=0.95)) such that return is greater than the benchmark
        minVaRretoverBM = which.min(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"]>=cumulativeReturn(benchmarkreturns[infrom:into])),"modifiedVaR.period"])
        if (length(minVaRretoverBM)==0) { minVaRretoverBM = maxReturn }

        #for utility function
        #w' = max(return) such that modifiedVaR is less than modifiedVaR(benchmark)
        maxmodVaRltBM=which.max(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.period"]<modifiedVaR(benchmarkreturns[infrom:into],p=0.95)),"Cumulative.Return"])
        if (length(maxmodVaRltBM)==0) { maxmodVaRltBM = 1 }

        #add utility functions tor Equal weighted portfolio
        # for utility function
        # w' = min(modifiedVaR(p=0.95)) such that return is greater than equal weighted portfolio
        minVaRretoverEW = which.min(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][1:portfoliorows,"Cumulative.Return"]>=portfolioreturns[[yearname]][1,"Cumulative.Return"]),"modifiedVaR.period"])
        if (length(minVaRretoverEW)==0) { minVaRretoverEW = 1 }

        #for utility function
        #w' = max(return) such that modifiedVaR is less than modifiedVaR(equal weighted)
        maxmodVaRltEW=which.max(portfolioreturns[[yearname]][which(portfolioreturns[[yearname]][1:portfoliorows,"modifiedVaR.period"]<portfolioreturns[[yearname]][1,"Cumulative.Return"]),"Cumulative.Return"])
        if (length(maxmodVaRltEW)==0) { maxmodVaRltEW = NA }

        #for utility function
        #w' = max(omega)
        maxOmega = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Omega"])

        #for utility function
        #w' = max(Sharpe.period)
        maxPeriodSharpe = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Sharpe.period"])

        #for utility function
        #w' = max(Sharpe.3.yr)
        max3yrSharpe = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Sharpe.3.yr"])

        #for utility function
        #w' = max(Sharpe.inception)
        #maxInceptionSharpe = which.max(portfolioreturns[[yearname]][1:portfoliorows,"Sharpe.inception"])


        ########## end of utility functions ##########
        # construct a data structure that holds each result for this row
        if (rnum==2) {
                #create data.frame
                result=data.frame()
                resultrow=data.frame()
        }
        # first cbind the columns
        resultrow = cbind(EqualWeighted, minmodVaR, minmodVaR3yr, modSharpe3yr, ReturnOverDrawdown, maxReturn,
                           minVaRretoverBM, maxmodVaRltBM, minVaRretoverEW, maxmodVaRltEW,
                           maxPeriodSharpe, max3yrSharpe, maxOmega )

        rownames(resultrow) = outname

        # then rbind the rows
        result    = rbind(result,resultrow)
        # print(resultarray)
    }  # end row loop

    # Result:
    result
}

# ------------------------------------------------------------------------------
BacktestDisplay =
function (R, portfolioreturns, yeargrid, backtestresults, show="Cumulative.Return", benchmarkreturns )
{ # a function by Brian G. Peterson

    # Description:
    # This function lets us use the output of the Backtest() function to do some
    # comparative analysis of how each utility function performed out of sample.
    # It takes as input all the component parts, and shows a single summary statistic
    # for each out of sample period for each utility function.  Periods are rows,
    # utility functions are columns in the output.
    # Eventually, we'll want to make this more sophisticated, and return a
    # data structure with *all* the summary statistics for each out-of-sample portfolio,
    # but this works for now.
    #
    # R                 data frame of historical returns
    #
    # portfolioreturns  list of data frames of set of returns for all possible portfolios
    #                   (output of BruteForcePortfolios function)
    #
    # yeargrid          list of from/to vectors for the periods we've run the backtest over
    #                   yeargrid will have one row for the last out of sample year,
    #                   which is not calculated by BruteForcePortfolios
    #
    # backtestresults   data frame of set of weighting vectors for each
    #                   utility function in each year/period
    #                   (output of Backtest function)
    #
    # show              column name to display from portfolioreturns row
    #                   corresponding to weighting vector
    #
    # benchmarkreturns  return vector for benchmark, should match the dates on
    #                   the in-sample portfolio returns

    # Setup:
    rows=nrow(yeargrid)-1  #hack to deal with incomplete data in current year

    benchmarkreturns = as.vector(benchmarkreturns)

    # Function:
    for (rnum in 1:rows) {
        yearrow   = yeargrid[rnum,]
        from      = yearrow [,1]
        to        = yearrow [,2]
        yearname  = rownames(yearrow)

        # construct a data structure that holds each result for this row
        if (rnum==1) {
                #create data.frame
                result=data.frame()
                resultrow=data.frame()
        }
        #if(rnum==rows){return}

        # now build our results
        Benchmark     = cumulativeReturn (benchmarkreturns[from:to]) #do something spiffy to show the same stats for FoHF index

        # don't need this anymore since we put it in the backtest column grid
        # EqualWeighted = portfolioreturns[[yearname]][1,show]

        #get funky with the backtest array
        backtestrow=t(portfolioreturns[[yearname]][t(backtestresults[yearname,]),show])

        #print(backtestrow)
        colnames(backtestrow)=colnames(backtestresults)

        # first cbind the columns
        resultrow = cbind( Benchmark, backtestrow)

        rownames(resultrow) = yearname

        # then rbind the rows
        result    = rbind(result,resultrow)
        # print(resultarray)

    } # end rows loop

    #Result:
    result

}

# ------------------------------------------------------------------------------
BacktestWeightDisplay =
function(backtestresults, yeargrid, weightgrid, R)
{ # @author Brian G. Peterson

    # Description:
    # Display the weights chosen for each year/period for each utility function.
    #
    # backtestresults   data frame of set of weighting vectors for each
    #                   utility function in each year/period
    #                   (output of Backtest function)
    #
    # yeargrid          list of from/to vectors for the periods we've run the backtest over
    #                   yeargrid will have one row for the last out of sample year,
    #                   which is not calculated by BruteForcePortfolios
    #
    # weightgrid        each row contains one weighting vector, same number of columns as your returns
    #
    # R                 data frame of historical returns
    #
    # Return:
    # list of years/periods with each period containing a data frame of weights by utiltiy function

    # Setup:
    rows=nrow(yeargrid)-1 # take out the first in-sample year

    cols = ncol(backtestresults) # get the number of utility functions
    componentnames = colnames(R)
    utilitynames   = colnames (backtestresults)

    # Function:
    # first loop on out of sample years/periods
    for (rnum in 2:rows) {
        row = yeargrid[rnum,]
        yearname=rownames(row)
        # print(yearname)
        if (rnum==2) {
            #create empty list, as c() doesn't work the way you would expect with a list
            result=vector("list")
        }

        # now loop on all the utility functions
        for (col in 1:cols) {
            weightingvectornum = backtestresults[rnum,col]
            #print (weightingvectornum)
            weightingvector    = weightgrid[weightingvectornum,]
            print (weightingvector)
            utilityname=colnames(backtestresults[rnum,col])
            print (utilityname)
            utilityrow = c(t(weightingvector),utilityname)
            #rownames(utilityrow)=rownames(weightingvector)
            #print(utilityrow)
            if (col==1){
                currentyeardata=data.frame(utilityrow=utilityrow)
            } else {
                currentyeardata=rbind(currentyeardata,utilityrow)
            }
        } # end utility functions loop

        colnames(currentyeardata)=c(componentnames,"Utility Function")
        #assign each year into the list using the yearname as the index
        result[[yearname]]=currentyeardata

    } # end years/periods loop
    names(result) = t(rownames(yeargrid[2:rows,]))

    #Return:
    result
}


# ------------------------------------------------------------------------------
#MonthlyBacktestResults =
# use pfolioReturn(returnarray,weightingvector) from fPortfolio
MonthlyBacktestResults =
function (R, weightgrid, yeargrid, backtestweights)
{ # @author Brian G. Peterson

    # R                 data structure of component returns
    #
    # weightgrid        each row contains one weighting vector, same number of columns as your returns
    #
    # yeargrid          list of from/to vectors for the periods we want to backtest over
    #
    # backtestweights
    #
    # @returns      data frame where each row has the same index number as a weighting vector,
    #               and each column is one of your metrics from inside this function
    #
    # @example      myreturns=MonthlyBacktestResults(edhec.returns[,1:10], weightingvectors, yeargrid, backtest)

    # Setup:
    rows=nrow(backtestweights)-1
    ##rows=nrow(yeargrid)
    testcols=ncol(backtestweights)
    result=NA

    # data type conditionals
    # cut the return series for from:to
    if (class(R) == "timeSeries") {
        R = R@Data
    } else {
        R = R
    }

    if (ncol(weightgrid) != ncol(R)) stop ("The Weighting Vector and Return Collection do not have the same number of Columns.")


    # Function:
    for(row in 1:rows) {
        yearname  = rownames(backtestweights[row,])
        yearrow   = yeargrid[yearname,]
        from      = yeargrid [yearname,1]
        to        = yeargrid [yearname,2]

        # ok, we're looping on year.
        # for each year, we need to apply the weights in our backtest results to the portfolio and get a monthly return

        for (col in 1:testcols) {

            w = as.numeric(weightgrid[backtestweights[row,col],])

            # pfolioReturn
            colreturn=pfolioReturn(R[from:to,],w)

            if (col==1) {
                # add the edhec returns
                # edhec = NA

                # add the equal weighted portfolios
                equalweight = pfolioReturn(R[from:to,],as.numeric(weightgrid[1,]))
                #colnames(equalweight)="EqualWeighted"

                #create data.frame
                resultcol=data.frame(Value=equalweight)
            }

            mycol=data.frame(Value=colreturn)
            resultcol=cbind(resultcol,mycol)

        }
        colnames(resultcol)=c("EqualWeighted",colnames(backtestweights))
        if (row==1) {
                #create data.frame
                result=data.frame(resultcol)
        } else {
            resultrow = data.frame(resultcol)
            result    = rbind(result,resultrow)
        }

    } #end rows loop

    # set pretty labels for things eventually

    # Return Value:
    result

}


# ------------------------------------------------------------------------------
# GeometricReturn
# use annualizedReturn or cumulativeReturn from Peter Carl in performance-analytics.R

###############################################################################
# $Log: not supported by cvs2svn $
# Revision 1.18  2006/12/03 17:42:02  brian
# - adjust utility functions in Backtest() to match 3yr statistices from BruteForcePortfolios
# - add more descriptive comments to BacktestDisplay()
# - add BacktestWeightDisplay() fn, not yet complete
# Bug 840
#
# Revision 1.17  2006/12/02 12:54:53  brian
# - modify BacktestData() fn to take a 'yeargrid' that matches
#    yeargrid from BruteForcePortfolios and loads those portfolios
# Bug 840
#
# Revision 1.16  2006/11/30 00:24:11  brian
# - remove 'inception' statistics from BruteForcePortfolios and Backtest fns
# - fix error in 'show' parameter of BacktestDisplay fn
# Bug 840
#
# Revision 1.15  2006/11/28 02:52:03  brian
# - add 3yr modSharpe and 3yr modVaR
# - add fOptions require for Omega
# Bug 840
#
# Revision 1.14  2006/10/12 17:42:48  brian
# - put back omega utility fn
#
# Revision 1.13  2006/09/26 23:42:53  brian
# - add Equalweighted as column in Backtest vector fns
# - clean up NA handling in utility functions
# - add more error handling
#
# Revision 1.12  2006/09/26 21:53:41  brian
# - more fixes for NA's in data
#
# Revision 1.11  2006/09/26 12:07:04  brian
#  - add more NA handlinf and data series size checks
#  - comment out Omega for speed for now
#
# Revision 1.10  2006/09/22 15:30:44  brian
# - add separate vector to BacktestDisplay fn for benchmark returns
#
# Revision 1.9  2006/09/22 12:45:45  brian
# - add separate vector for benckmarkreturns to Backtest fn
# - better describe inputs to Backtest fn in comments
#
# Revision 1.8  2006/09/21 13:43:39  brian
# - add start timestamp for Backtest function
#
# Revision 1.7  2006/09/12 14:37:43  brian
# - add CVS tags
# - add CVS log
# - add confidentiality notice to top of file
#
# Revision 1.6 2006-09-12 09:31:37 brian
# - snapshot 2006-09-05 15:36
# - add functions and tweak existing to better handle larger data sets, cutting data
#
# Revision 1.5 2006-09-12 09:29:12 brian
# - snapshot 2006-08-30 19:03
# - add functions for conthly compounding returns
#
# Revision 1.4 2006-09-12 09:28:01 brian
# - snapshot 2006-08-29 23:01
# - add equal weighted utility functions
#
# Revision 1.3 2006-09-12 09:27:00 brian
# - snapshot 2006-08-29 21:58
# - Add functions to actually perform the backtest
#   using the results of the brute force statistics
#   generated on all possible portfolios.
#
# Revision 1.2 2006-09-12 09:25:06 brian
# - snapshot 2006-08-29
# - add BruteForcePortfolios, WeightedReturns, and other small utility functions
#
# Revision 1.1 2006-09-12 09:23:14 brian
# - initial revision 2006-08-28
# Bug 840
###############################################################################